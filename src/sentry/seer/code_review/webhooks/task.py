from __future__ import annotations

import logging
from collections.abc import Mapping
from datetime import datetime, timezone
from typing import Any

from urllib3.exceptions import HTTPError

from sentry.integrations.github.webhook_types import GithubWebhookType
from sentry.models.organization import Organization
from sentry.models.repository import Repository
from sentry.seer.code_review.models import (
    SeerCodeReviewTaskRequestForPrClosed,
    SeerCodeReviewTaskRequestForPrReview,
)
from sentry.seer.code_review.utils import transform_webhook_to_codegen_request
from sentry.silo.base import SiloMode
from sentry.tasks.base import instrumented_task
from sentry.taskworker.namespaces import seer_code_review_tasks
from sentry.taskworker.retry import Retry
from sentry.taskworker.state import current_task
from sentry.utils import metrics

from ..event_recorder import find_event_by_trigger_id, update_event_status
from ..metrics import WebhookFilteredReason, record_webhook_enqueued, record_webhook_filtered
from ..utils import convert_enum_keys_to_strings, get_seer_endpoint_for_event, make_seer_request

logger = logging.getLogger(__name__)


PREFIX = "seer.code_review.task"
MAX_RETRIES = 5
DELAY_BETWEEN_RETRIES = 60  # 1 minute
RETRYABLE_ERRORS = (HTTPError,)


def schedule_task(
    github_event: GithubWebhookType,
    github_event_action: str,
    event: Mapping[str, Any],
    organization: Organization,
    repo: Repository,
    target_commit_sha: str,
    event_record: Any | None = None,
) -> None:
    trigger_id = getattr(event_record, "trigger_id", None) if event_record else None

    transformed_event = transform_webhook_to_codegen_request(
        github_event=github_event,
        github_event_action=github_event_action,
        event_payload=dict(event),
        organization=organization,
        repo=repo,
        target_commit_sha=target_commit_sha,
        trigger_id=trigger_id,
    )

    if transformed_event is None:
        record_webhook_filtered(
            github_event, github_event_action, WebhookFilteredReason.TRANSFORM_FAILED
        )
        update_event_status(event_record, "webhook_filtered", denial_reason="transform_failed")
        return

    process_github_webhook_event.delay(
        github_event=github_event.value,
        event_payload=transformed_event,
        enqueued_at_str=datetime.now(timezone.utc).isoformat(),
        trigger_id=trigger_id,
    )
    record_webhook_enqueued(github_event, github_event_action)
    update_event_status(event_record, "task_enqueued")


@instrumented_task(
    name="sentry.seer.code_review.tasks.process_github_webhook_event",
    namespace=seer_code_review_tasks,
    retry=Retry(times=MAX_RETRIES, delay=DELAY_BETWEEN_RETRIES, on=RETRYABLE_ERRORS),
    silo_mode=SiloMode.REGION,
)
def process_github_webhook_event(
    *,
    enqueued_at_str: str,
    github_event: str,
    event_payload: Mapping[str, Any],
    trigger_id: str | None = None,
    **kwargs: Any,
) -> None:
    """Validate and forward webhook event payload to Seer."""
    event_record = find_event_by_trigger_id(trigger_id) if trigger_id else None

    status = "success"
    should_record_latency = True
    try:
        path = get_seer_endpoint_for_event(github_event).value

        # CHECK_RUN events use a minimal payload that doesn't need Pydantic validation
        if github_event != GithubWebhookType.CHECK_RUN:
            request_type = event_payload.get("request_type")
            validated_payload: (
                SeerCodeReviewTaskRequestForPrClosed | SeerCodeReviewTaskRequestForPrReview
            )
            if request_type == "pr-closed":
                validated_payload = SeerCodeReviewTaskRequestForPrClosed.parse_obj(event_payload)
            else:
                validated_payload = SeerCodeReviewTaskRequestForPrReview.parse_obj(event_payload)
            # Pydantic v1 converts string keys to enums; convert back for JSON serialization
            payload = convert_enum_keys_to_strings(validated_payload.dict())
        else:
            payload = event_payload

        log_seer_request(event_payload, github_event)
        make_seer_request(path=path, payload=payload)
        update_event_status(event_record, "sent_to_seer")
    except Exception as e:
        status = e.__class__.__name__
        update_event_status(event_record, "review_failed")
        # Retryable errors are automatically retried by taskworker.
        if isinstance(e, RETRYABLE_ERRORS):
            task = current_task()
            if task and task.retries_remaining:
                should_record_latency = False
        raise
    finally:
        if status != "success":
            metrics.incr(f"{PREFIX}.error", tags={"error_status": status}, sample_rate=1.0)
        if should_record_latency:
            record_latency(status, enqueued_at_str)


def log_seer_request(event_payload: Mapping[str, Any], github_event: str) -> None:
    repo_data = event_payload.get("data", {}).get("repo", {})
    trigger_at_str = event_payload.get("data", {}).get("config", {}).get("trigger_at")
    logger.info(
        "%s.sending_request_to_seer",
        PREFIX,
        extra={
            "provider": repo_data.get("provider"),
            "repo_owner": repo_data.get("owner"),
            "repo_name": repo_data.get("name"),
            "pr_id": event_payload.get("data", {}).get("pr_id"),
            "commit_sha": repo_data.get("base_commit_sha"),
            "request_type": event_payload.get("request_type"),
            "github_event": github_event,
            "github_to_seer_latency_ms": (
                calculate_latency_ms(trigger_at_str) if trigger_at_str else None
            ),
        },
    )


def record_latency(status: str, enqueued_at_str: str) -> None:
    latency_ms = calculate_latency_ms(enqueued_at_str)
    if latency_ms > 0:
        metrics.timing(f"{PREFIX}.e2e_latency", latency_ms, tags={"status": status})


def calculate_latency_ms(timestamp_str: str) -> int:
    """Calculate the latency in milliseconds between the given timestamp and now."""
    try:
        timestamp = datetime.fromisoformat(timestamp_str)
        now = datetime.now(timezone.utc)
        return int((now - timestamp).total_seconds() * 1000)
    except (ValueError, TypeError) as e:
        # Don't fail the task if timestamp parsing fails
        logger.warning(
            "%s.invalid_timestamp",
            PREFIX,
            extra={"timestamp": timestamp_str, "error": str(e)},
        )
        return 0
